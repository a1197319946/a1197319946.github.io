<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java," />





  <link rel="alternate" href="/atom.xml" title="疯狂DD" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="引言最近辞职，开始了一轮又一轮腥风血雨的面试，开个专栏，记录下面试中的各种疑难杂症问题，面试的公司有58企服、便利蜂，美团等，给大家分享下。专栏将分为几部分：java基础、数据库部分、分布式架构中间件部分、网络及算法部分。本篇来说下基础部分。博主刚毕业一年，加上大四一年外包经验，工作两年，本以为面试应该比较轻松，面了发现还是挺难的……  可谓雄关漫道真如铁，而今迈步从头越，从头越，苍山如海，残阳如">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试之路（一）Java基础部分">
<meta property="og:url" content="https://a1197319946.github.io/2018/01/01/Java面试之路（一）Java基础部分/index.html">
<meta property="og:site_name" content="疯狂DD">
<meta property="og:description" content="引言最近辞职，开始了一轮又一轮腥风血雨的面试，开个专栏，记录下面试中的各种疑难杂症问题，面试的公司有58企服、便利蜂，美团等，给大家分享下。专栏将分为几部分：java基础、数据库部分、分布式架构中间件部分、网络及算法部分。本篇来说下基础部分。博主刚毕业一年，加上大四一年外包经验，工作两年，本以为面试应该比较轻松，面了发现还是挺难的……  可谓雄关漫道真如铁，而今迈步从头越，从头越，苍山如海，残阳如">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://img.blog.csdn.net/20171117144601868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnJpZ2h0aW5nZm9yYW1iaXRpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2018-01-01T12:37:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面试之路（一）Java基础部分">
<meta name="twitter:description" content="引言最近辞职，开始了一轮又一轮腥风血雨的面试，开个专栏，记录下面试中的各种疑难杂症问题，面试的公司有58企服、便利蜂，美团等，给大家分享下。专栏将分为几部分：java基础、数据库部分、分布式架构中间件部分、网络及算法部分。本篇来说下基础部分。博主刚毕业一年，加上大四一年外包经验，工作两年，本以为面试应该比较轻松，面了发现还是挺难的……  可谓雄关漫道真如铁，而今迈步从头越，从头越，苍山如海，残阳如">
<meta name="twitter:image" content="http://img.blog.csdn.net/20171117144601868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnJpZ2h0aW5nZm9yYW1iaXRpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://a1197319946.github.io/2018/01/01/Java面试之路（一）Java基础部分/"/>





  <title>Java面试之路（一）Java基础部分 | 疯狂DD</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">疯狂DD</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://a1197319946.github.io/2018/01/01/Java面试之路（一）Java基础部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D_xiao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="疯狂DD">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java面试之路（一）Java基础部分</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-01T20:37:33+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试题/" itemprop="url" rel="index">
                    <span itemprop="name">面试题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近辞职，开始了一轮又一轮腥风血雨的面试，开个专栏，记录下面试中的各种疑难杂症问题，面试的公司有58企服、便利蜂，美团等，给大家分享下。专栏将分为几部分：java基础、数据库部分、分布式架构中间件部分、网络及算法部分。本篇来说下基础部分。博主刚毕业一年，加上大四一年外包经验，工作两年，本以为面试应该比较轻松，面了发现还是挺难的……</p>
<blockquote>
<p>可谓雄关漫道真如铁，而今迈步从头越，从头越，苍山如海，残阳如血。</p>
</blockquote>
<hr>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="一、关于线程池"><a href="#一、关于线程池" class="headerlink" title="一、关于线程池"></a>一、关于线程池</h2><p> <strong>1. java自带的线程池</strong></p>
<p>  a. newCachedThreadPool(创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。)<br>  b.  newFixedThreadPool(创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。)<br>  c. newScheduledThreadPool(创建一个定长线程池，支持定时及周期性任务执行。)<br>  d.newSingleThreadExecutor(创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。)</p>
<p> <strong>2. 自己如何实现线程池</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">    .setNameFormat(&quot;demo-pool-%d&quot;).build();</span><br><span class="line"></span><br><span class="line">//Common Thread Pool</span><br><span class="line">ExecutorService pool = new ThreadPoolExecutor(5, 200,</span><br><span class="line">     0L, TimeUnit.MILLISECONDS,</span><br><span class="line">     new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">pool.shutdown();//gracefully shutdown</span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</li>
<li>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li>
<li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li>
<li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>
<pre><code>TimeUnit.DAYS;               //天 TimeUnit.HOURS;             //小时
TimeUnit.MINUTES;           //分钟 TimeUnit.SECONDS;           //秒
TimeUnit.MILLISECONDS;      //毫秒 TimeUnit.MICROSECONDS;      //微妙
TimeUnit.NANOSECONDS;       //纳秒
</code></pre></li>
<li><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p>
</li>
</ul>
<pre><code>ArrayBlockingQueue; LinkedBlockingQueue; SynchronousQueue;
</code></pre><p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p>
<ul>
<li>threadFactory：线程工厂，主要用来创建线程；</li>
<li><p>handler：表示当拒绝处理任务时的策略，有以下四种取值：</p>
<pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
</code></pre></li>
</ul>
<h2 id="二、关于Lock和Synchronized"><a href="#二、关于Lock和Synchronized" class="headerlink" title="二、关于Lock和Synchronized"></a>二、关于Lock和Synchronized</h2><p> <strong>1. 两种锁有什么区别</strong></p>
<p> 1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，但是增加了锁投票，定时锁等候和中断锁等候，。比如ReentrantLock获取锁定与三种方式：</p>
<pre><code>a) lock(),如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁
b) tryLock(),如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false； 
c)tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时
间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；
d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程
被别的线程中断
</code></pre><p><strong>2 、ReentrantLock增加了等待条件，可以看ArrayBlockingQuene的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">        if (capacity &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        this.items = new Object[capacity];</span><br><span class="line">        lock = new ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition();//设置不空条件</span><br><span class="line">        notFull =  lock.newCondition();//设置不满条件</span><br><span class="line">    &#125;</span><br><span class="line">    public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();//等待队列不满条件</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>3、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中</p>
<p> 4、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</p>
<p> <strong>2. Synchronized修饰普通方法和静态方法有什么区别</strong></p>
<pre><code>修饰普通方法为对象锁，修饰静态方法为类锁
</code></pre><h2 id="三、HashMap底层原理"><a href="#三、HashMap底层原理" class="headerlink" title="三、HashMap底层原理"></a>三、HashMap底层原理</h2><p> <strong>1. 底层结构</strong></p>
<pre><code>数组+链表；jdk8优化后链表长度超过8会转化为红黑树
</code></pre><p> <strong>2. 散列算法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//jdk8已经进行简化，改为1次16位右移异或混合，而不是4次</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">        int h = hashSeed;</span><br><span class="line">        if (0 != h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//hashcode用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。获取下标</span><br><span class="line"> static int indexFor(int h, int length) &#123;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 扩容原理</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">//两倍扩容</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        hash = (null != key) ? hash(key) : 0;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>4. jdk8对HashMap的优化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 链表长度大于8时，改为红黑树结构</span><br><span class="line">// 实现如下：</span><br><span class="line"> private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">    if (tab != null) &#123;</span><br><span class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; 1);</span><br><span class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</span><br><span class="line">            synchronized (b) &#123;</span><br><span class="line">                if (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              null, null);</span><br><span class="line">                        if ((p.prev = tl) == null)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        else</span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//红黑树的具体实现需要了解下</span><br></pre></td></tr></table></figure>
<p> <strong>5.  HashMap put方法原理</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">//允许key为null</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">//key不是null时计算哈希值得到数组下标</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">//遍历该位置链表，如果已有此value则直接进行替换，并返回原来的值</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//如果不存在此value,则插入节点</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>6. HashMap如何调整性能</strong></p>
<pre><code>适当修改分组组数及加载因子（默认16*0.75），保证分组组数* 加载因子&gt;元素总量，避免由于出发扩容重新散列印象效率。另，
分组组数越大，数据将被散列到更多的小组，查询效率高；加载因子越小，扩容发生的越早，也就是在尽可能的保证效率。
</code></pre><p> <strong>7. HashMap是否线程安全</strong></p>
<pre><code>HashMap不支持多个线程并发操作，会出现并发错误，在并发的场景下可以用HashTable，可以使用Collections工具类中的
synchronizedMap方法或者有更好的并发性能的ConcurrentHashMap
</code></pre><h2 id="四、TreeMap如何保证有序"><a href="#四、TreeMap如何保证有序" class="headerlink" title="四、TreeMap如何保证有序"></a>四、TreeMap如何保证有序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//在初始化时，构造器会传入一个比较器参数</span><br><span class="line"> public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">        this.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">//put时根据比较原则进行插入元素</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            compare(key, key); // type (and possibly null) check</span><br><span class="line"></span><br><span class="line">            root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">            size = 1;</span><br><span class="line">            modCount++;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        // split comparator and comparable paths</span><br><span class="line">        Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">        if (cpr != null) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                else</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t != null);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (key == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">            do &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                else</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t != null);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        else</span><br><span class="line">            parent.right = e;</span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、NIO与IO的区别及何种场景使用"><a href="#五、NIO与IO的区别及何种场景使用" class="headerlink" title="五、NIO与IO的区别及何种场景使用"></a>五、NIO与IO的区别及何种场景使用</h2><p><strong>1 使用场景</strong></p>
<pre><code>**NIO**

优势在于一个线程管理多个通道；但是数据的处理将会变得复杂；
如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，采用这种； 

**传统的IO** 

适用于一个线程管理一个通道的情况；因为其中的流数据的读取是阻塞的；
如果需要管理同时打开不太多的连接，这些连接会发送大量的数据；
</code></pre><p><strong>2 NIO vs IO区别</strong></p>
<p>1 IO是面向流的，NIO是面向缓冲区的</p>
<pre><code>a Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方；
b NIO则能前后移动流中的数据，因为是面向缓冲区的
</code></pre><p>2 IO流是阻塞的，NIO流是不阻塞的</p>
<pre><code>a Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或
数据完全写入。该线程在此期间不能再干任何事情了
b Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用
时，就什么都不会获取。NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可
能会比从一个阻塞流中读取数据更复杂。 
c 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。
</code></pre><p>3 选择器</p>
<pre><code>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线
程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容
易来管理多个通道。 
</code></pre><h2 id="六、CAS和CAP"><a href="#六、CAS和CAP" class="headerlink" title="六、CAS和CAP"></a>六、CAS和CAP</h2><p> <strong>1. CAS</strong></p>
<p> CAS:Compare and Swap, 翻译成比较并交换。<br>java.util.concurrent包中借助CAS实现了区别于synchronouse同步锁的一种乐观锁。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//可以看下AtomicInteger的源码 i++操作</span><br><span class="line">private volatile int value;</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;   </span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">//compareAndSwapInt方法即拿预期值expect和this当前内存值比较，相同则返回true,并赋新值update.</span><br></pre></td></tr></table></figure>
<p> <strong>2. CAP</strong></p>
<blockquote>
<p> 引用一下  ~<br><a href="http://www.blogjava.net/hello-yun/archive/2012/04/27/376744.html" target="_blank" rel="noopener">CAP原理</a></p>
</blockquote>
<h2 id="七、JVM内存模型，jdk8有何种改进"><a href="#七、JVM内存模型，jdk8有何种改进" class="headerlink" title="七、JVM内存模型，jdk8有何种改进"></a>七、JVM内存模型，jdk8有何种改进</h2><p>  jvm内存由堆、栈、本地方法栈、方法区等组成</p>
<ol>
<li>堆。存放通过new创建的对象，分新生代、老年代</li>
<li>栈。每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。  -xss:设置每个线程的堆栈大小. JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</li>
<li>本地方法栈。用于支持native方法的执行，存储了每个native方法调用的状态</li>
<li>方法区 。即持久代Permanet Space.</li>
</ol>
<p>下图为堆内存模型（图有点问题，持久带为方法区，不应该画在堆内存中）。<br><img src="http://img.blog.csdn.net/20171117144601868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnJpZ2h0aW5nZm9yYW1iaXRpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>普及一下gc算法：</p>
<pre><code>年轻代：
复制算法。 此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复
制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问
题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。

老年代：
并行（标记清除）。关于标记清除算法：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，
把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。

并行回收（标记整理）.关于标记整理算法： 此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所
有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问
题，同时也避免了“复制”算法的空间问题。
</code></pre><p>顺便提一下对象何时进行销毁：</p>
<pre><code>这也是面试官喜欢问的一个问题，一般我们会回答对象在gc的时候进行销毁，那面试官又会问，gc的时候jvm怎么知道该销毁哪些对象呢？这个问
题有点恶心，多次碰到简单说下：一个对象创建后被放置在JVM的堆内存中，当永远不再引用这个对象时，它将被JVM在堆内存中回收。即当对象在
JVM运行空间中无法通过根集合到达(找到)时,这个对象被称为垃圾对象。根集合是由类中的静态引用域与本地引用域组成的。JVM通过根集合索引
对象。 
这时面试官又会问，那什么情况下对象不会被回收呢（问的是内存泄露什么时候会发生），请把滚动条拉到最下面基础中基础，第一题有总结。
</code></pre><p>主要来说下jdk8的改进：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以元空间取代永久代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间</span><br><span class="line">并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</span><br><span class="line"></span><br><span class="line">　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</span><br><span class="line"></span><br><span class="line">　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</span><br><span class="line">　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</span><br><span class="line">　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。</span><br><span class="line"></span><br><span class="line">jvm参数不再需要指定 PermSize 和 MaxPermSize。而是指定 MetaSpaceSize 和 MaxMetaSpaceSize的大小。</span><br></pre></td></tr></table></figure></p>
<h2 id="八、JVM调优"><a href="#八、JVM调优" class="headerlink" title="八、JVM调优"></a>八、JVM调优</h2><p> <strong>1. jvm参数修改包括堆内存设置及垃圾回收器设置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，过多的GC和Full GC是会占用很多的系统资源（主要是CPU），</span><br><span class="line">影响系统的吞吐量。特别要关注Full GC，因为它会对整个堆进行整理。</span><br><span class="line">出现Full GC的几种原因：</span><br><span class="line"></span><br><span class="line"> 1. 老年代空间不足</span><br><span class="line"> 2. 新生代设置过小或过大</span><br><span class="line">   过小会导致大对象直接进入老年代，诱发full gc;</span><br><span class="line">   过大会导致老年代过小（堆总量一定），诱发full gc，另外会导致新生代gc耗时严重,</span><br><span class="line">   新生代最好占堆内存 1/3 或 3/8</span><br><span class="line"> 3. Survivor或Eden区设置过小或过大</span><br><span class="line">   过小导致对象从Eden区直接进去到老年代</span><br><span class="line">   过大导致Eden过小，增加了GC频率</span><br><span class="line">   可以使用-XX:SurvivorRatio=n 手动设置，默认n为8，即Survivor1：Survivor0：Eden=1:1:8</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">另外，可选择适合该应用的垃圾回收器：</span><br><span class="line"></span><br><span class="line"> XX:+UseSerialGC:设置串行收集器</span><br><span class="line">-XX:+UseParallelGC:设置并行收集器</span><br><span class="line">-XX:+UseParalledlOldGC:设置并行年老代收集器</span><br><span class="line">-XX:+UseConcMarkSweepGC:设置并发收集器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">垃圾回收统计信息：</span><br><span class="line">-XX:+PrintGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br></pre></td></tr></table></figure>
<p> <strong>2. 代码调优，防止大对象，大数组频繁创建</strong></p>
<h2 id="九、CPU和内存飙升的一般情况和解决思路"><a href="#九、CPU和内存飙升的一般情况和解决思路" class="headerlink" title="九、CPU和内存飙升的一般情况和解决思路"></a>九、CPU和内存飙升的一般情况和解决思路</h2><p> <strong>1. 内存飙升可能与线程阻塞、死循环有关，解决方法如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 使用jps查找出java进程的pid，如3707</span><br><span class="line">2 使用top -p 3707观察进程情况，然后Shift+h,显示该进程的所有线程。</span><br><span class="line">3 找出CPU消耗较多的线程id，如3720，将3720转换为16进制0x7d0，注意是小写哦</span><br><span class="line">4 使用jstack 3707 | grep -A 10 0x7d0 来查询出具体的线程状态。</span><br></pre></td></tr></table></figure>
<p> <strong>2. 内存占用高一般是创建对象太多，或有大数组之类，排查方式：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 通过jstat -gc -h10 pid 1000 查看gc情况</span><br><span class="line"> 通过jmap -heap pid 查看堆内存情况</span><br><span class="line"> 通过jmap -histo pid 查看堆中对象创建情况    </span><br><span class="line"> 关于内存溢出除了对象创建频繁另外的一种可能性：由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久</span><br><span class="line">代的内存溢出。最典型的场景就是，在JSP页面比较多的情况，容易出现永久代内存溢出。</span><br></pre></td></tr></table></figure>
<h2 id="十、Quene的原理"><a href="#十、Quene的原理" class="headerlink" title="十、Quene的原理"></a>十、Quene的原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">主要说一下java阻塞队列BlockingQuene。</span><br><span class="line">它的入队出队主要有几种方法：</span><br><span class="line"></span><br><span class="line"> 1. add remove 队列满的时候会抛异常</span><br><span class="line"> 2. offer poll 队列满了会返回false</span><br><span class="line"> 3. put take 队列满了会阻塞（等待）</span><br><span class="line">当然我们用阻塞的话只能用最后一种方式，</span><br><span class="line">常用的实现有两种ArrayBlockingQueue、LinkedBlockingQueue</span><br><span class="line">ArrayBlockingQueue实现如下：</span><br><span class="line"></span><br><span class="line">  public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            return extract();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    可以看到使用一个ReentrantLock实现的，而LinkedBlockingQueue的实现略有不同，用了两个ReentrantLock。来看下：</span><br><span class="line">     public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        if (e == null) throw new NullPointerException();</span><br><span class="line">        // Note: convention in all put/take/etc is to preset local var</span><br><span class="line">        // holding count negative to indicate failure unless set.</span><br><span class="line">        int c = -1;</span><br><span class="line">        Node&lt;E&gt; node = new Node(e);</span><br><span class="line">        final ReentrantLock putLock = this.putLock;</span><br><span class="line">        final AtomicInteger count = this.count;</span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Note that count is used in wait guard even though it is</span><br><span class="line">             * not protected by lock. This works because count can</span><br><span class="line">             * only decrease at this point (all other puts are shut</span><br><span class="line">             * out by lock), and we (or some other waiting put) are</span><br><span class="line">             * signalled if it ever changes from capacity. Similarly</span><br><span class="line">             * for all other uses of count in other wait guards.</span><br><span class="line">             */</span><br><span class="line">            while (count.get() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            if (c + 1 &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        if (c == 0)</span><br><span class="line">            signalNotEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    public E take() throws InterruptedException &#123;</span><br><span class="line">        E x;</span><br><span class="line">        int c = -1;</span><br><span class="line">        final AtomicInteger count = this.count;</span><br><span class="line">        final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count.get() == 0) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            if (c &gt; 1)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        if (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">//入队和出队是不同的锁</span><br></pre></td></tr></table></figure>
<h2 id="十一、介绍了解的设计模式"><a href="#十一、介绍了解的设计模式" class="headerlink" title="十一、介绍了解的设计模式"></a>十一、介绍了解的设计模式</h2><p> <strong>1. 单例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//醉汉</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private Singleton()&#123;&#125;;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    public static Singleton getInstance ()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">//懒汉</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">            if(instance == null &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">           return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//对懒汉模式加锁的优化（volatile+双重锁）</span><br><span class="line"> public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">            if(instance == null &#123;</span><br><span class="line">                synchronized（Singleton.class）&#123;</span><br><span class="line">           if(instance == null)&#123;</span><br><span class="line">                        instance = new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>2. 工厂</strong><br> <strong>3. 代理</strong><br> <strong>4. 包装</strong><br> ………..</p>
<h2 id="十二、volatile为什么能支持同步，却不支持原子性？"><a href="#十二、volatile为什么能支持同步，却不支持原子性？" class="headerlink" title="十二、volatile为什么能支持同步，却不支持原子性？"></a>十二、volatile为什么能支持同步，却不支持原子性？</h2><p>这两句话看起来好像是矛盾的，我们来一一分析下。</p>
<p>　　首先，我们知道volatile是一个线程安全的修饰符，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。<br>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。<br>　　当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p>
<p>　　<br>当一个变量定义为 volatile 之后，将具备两种特性：</p>
<p>　　1.保证此变量对所有的线程的可见性，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次get时立即从主内存刷新。<br>　　2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），所以就禁止了cpu的重排序操作。<br>　　<br>volatile 性能：</p>
<p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
<p><strong>当变量用volatile修饰是，从上面可以知道set/get 都是线程安全的，但这是否说明volatile是原子的？</strong><br>答案是否定的，比如i++ , 这个操作实际是 i = i + 1, 它不是一个原子的行为，在操作的过程中，是不安全的，如要实现安全，可采用CAS方案进行同步，像AtomicInteger、AtomicLong等就是基于volatile的可见性 + CAS控制 i++操作的原子性的。
　　</p>
<hr>
<p>以上为我接触的感觉基础中比较深入的问题，下面的问题我感觉比较简单但是必须熟练掌握，答案不一一列举。有问题的自行百度，如若无果请留言。</p>
<hr>
<h2 id="Java基础中的基础"><a href="#Java基础中的基础" class="headerlink" title="Java基础中的基础"></a>Java基础中的基础</h2><p>一、内存溢出和内存泄露发生原因<br>1 内存溢出（比较简单暂不列举）<br>2 内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。<br>内存泄露的原因：</p>
<pre><code>1、静态集合类引起内存泄露： 
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 
2 各种连接、流未关闭
</code></pre><p>二、集合框架对比</p>
<ol>
<li>ArrayList与linkedList、Vector的区别</li>
<li>HashMap与HashTable的区别</li>
<li>TreepMap,SortedMap比较器的用法</li>
<li>ArrayList扩容机制<br> jdk1.7 前 a*1.5 + 1<br>jdk1.7 后 a + a&gt;&gt;1</li>
</ol>
<p>三、接口抽象类的区别</p>
<ol>
<li>接口中定义的变量默认即常量；抽象类中变量为普通属性，每个对象都有一份。</li>
<li>接口中的方法都是抽象方法不能写实现，抽象类中中可以有抽象方法也可以有非抽象方法，也就是说可以有实现</li>
<li>jdk8开始接口中的方法可以写具体实现，static修饰的静态方法和default修饰的默认方法</li>
</ol>
<p>四、线程的生命周期<br>新建、就绪、运行、阻塞、死亡</p>
<blockquote>
<p>先写这么多，后面待续………..</p>
</blockquote>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>捧个钱场？</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="D_xiao WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="D_xiao Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/01/test1/" rel="prev" title="Java面试之路（二）数据库部分">
                Java面试之路（二）数据库部分 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="D_xiao" />
          <p class="site-author-name" itemprop="name">D_xiao</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/frightingforambition" target="_blank" title="csdn">
                  
                    <i class="fa fa-fw fa-heartbeat"></i>
                  
                    
                      csdn
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x5F15;&#x8A00;" class="headerlink" title="&#x5F15;&#x8A00;"></a>&#x5F15;&#x8A00;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java基础"><span class="nav-number">2.</span> <span class="nav-text"><a href="#Java&#x57FA;&#x7840;" class="headerlink" title="Java&#x57FA;&#x7840;"></a>Java&#x57FA;&#x7840;</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、关于线程池"><span class="nav-number">2.1.</span> <span class="nav-text"><a href="#&#x4E00;&#x3001;&#x5173;&#x4E8E;&#x7EBF;&#x7A0B;&#x6C60;" class="headerlink" title="&#x4E00;&#x3001;&#x5173;&#x4E8E;&#x7EBF;&#x7A0B;&#x6C60;"></a>&#x4E00;&#x3001;&#x5173;&#x4E8E;&#x7EBF;&#x7A0B;&#x6C60;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、关于Lock和Synchronized"><span class="nav-number">2.2.</span> <span class="nav-text"><a href="#&#x4E8C;&#x3001;&#x5173;&#x4E8E;Lock&#x548C;Synchronized" class="headerlink" title="&#x4E8C;&#x3001;&#x5173;&#x4E8E;Lock&#x548C;Synchronized"></a>&#x4E8C;&#x3001;&#x5173;&#x4E8E;Lock&#x548C;Synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、HashMap底层原理"><span class="nav-number">2.3.</span> <span class="nav-text"><a href="#&#x4E09;&#x3001;HashMap&#x5E95;&#x5C42;&#x539F;&#x7406;" class="headerlink" title="&#x4E09;&#x3001;HashMap&#x5E95;&#x5C42;&#x539F;&#x7406;"></a>&#x4E09;&#x3001;HashMap&#x5E95;&#x5C42;&#x539F;&#x7406;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、TreeMap如何保证有序"><span class="nav-number">2.4.</span> <span class="nav-text"><a href="#&#x56DB;&#x3001;TreeMap&#x5982;&#x4F55;&#x4FDD;&#x8BC1;&#x6709;&#x5E8F;" class="headerlink" title="&#x56DB;&#x3001;TreeMap&#x5982;&#x4F55;&#x4FDD;&#x8BC1;&#x6709;&#x5E8F;"></a>&#x56DB;&#x3001;TreeMap&#x5982;&#x4F55;&#x4FDD;&#x8BC1;&#x6709;&#x5E8F;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、NIO与IO的区别及何种场景使用"><span class="nav-number">2.5.</span> <span class="nav-text"><a href="#&#x4E94;&#x3001;NIO&#x4E0E;IO&#x7684;&#x533A;&#x522B;&#x53CA;&#x4F55;&#x79CD;&#x573A;&#x666F;&#x4F7F;&#x7528;" class="headerlink" title="&#x4E94;&#x3001;NIO&#x4E0E;IO&#x7684;&#x533A;&#x522B;&#x53CA;&#x4F55;&#x79CD;&#x573A;&#x666F;&#x4F7F;&#x7528;"></a>&#x4E94;&#x3001;NIO&#x4E0E;IO&#x7684;&#x533A;&#x522B;&#x53CA;&#x4F55;&#x79CD;&#x573A;&#x666F;&#x4F7F;&#x7528;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、CAS和CAP"><span class="nav-number">2.6.</span> <span class="nav-text"><a href="#&#x516D;&#x3001;CAS&#x548C;CAP" class="headerlink" title="&#x516D;&#x3001;CAS&#x548C;CAP"></a>&#x516D;&#x3001;CAS&#x548C;CAP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、JVM内存模型，jdk8有何种改进"><span class="nav-number">2.7.</span> <span class="nav-text"><a href="#&#x4E03;&#x3001;JVM&#x5185;&#x5B58;&#x6A21;&#x578B;&#xFF0C;jdk8&#x6709;&#x4F55;&#x79CD;&#x6539;&#x8FDB;" class="headerlink" title="&#x4E03;&#x3001;JVM&#x5185;&#x5B58;&#x6A21;&#x578B;&#xFF0C;jdk8&#x6709;&#x4F55;&#x79CD;&#x6539;&#x8FDB;"></a>&#x4E03;&#x3001;JVM&#x5185;&#x5B58;&#x6A21;&#x578B;&#xFF0C;jdk8&#x6709;&#x4F55;&#x79CD;&#x6539;&#x8FDB;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、JVM调优"><span class="nav-number">2.8.</span> <span class="nav-text"><a href="#&#x516B;&#x3001;JVM&#x8C03;&#x4F18;" class="headerlink" title="&#x516B;&#x3001;JVM&#x8C03;&#x4F18;"></a>&#x516B;&#x3001;JVM&#x8C03;&#x4F18;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、CPU和内存飙升的一般情况和解决思路"><span class="nav-number">2.9.</span> <span class="nav-text"><a href="#&#x4E5D;&#x3001;CPU&#x548C;&#x5185;&#x5B58;&#x98D9;&#x5347;&#x7684;&#x4E00;&#x822C;&#x60C5;&#x51B5;&#x548C;&#x89E3;&#x51B3;&#x601D;&#x8DEF;" class="headerlink" title="&#x4E5D;&#x3001;CPU&#x548C;&#x5185;&#x5B58;&#x98D9;&#x5347;&#x7684;&#x4E00;&#x822C;&#x60C5;&#x51B5;&#x548C;&#x89E3;&#x51B3;&#x601D;&#x8DEF;"></a>&#x4E5D;&#x3001;CPU&#x548C;&#x5185;&#x5B58;&#x98D9;&#x5347;&#x7684;&#x4E00;&#x822C;&#x60C5;&#x51B5;&#x548C;&#x89E3;&#x51B3;&#x601D;&#x8DEF;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、Quene的原理"><span class="nav-number">2.10.</span> <span class="nav-text"><a href="#&#x5341;&#x3001;Quene&#x7684;&#x539F;&#x7406;" class="headerlink" title="&#x5341;&#x3001;Quene&#x7684;&#x539F;&#x7406;"></a>&#x5341;&#x3001;Quene&#x7684;&#x539F;&#x7406;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一、介绍了解的设计模式"><span class="nav-number">2.11.</span> <span class="nav-text"><a href="#&#x5341;&#x4E00;&#x3001;&#x4ECB;&#x7ECD;&#x4E86;&#x89E3;&#x7684;&#x8BBE;&#x8BA1;&#x6A21;&#x5F0F;" class="headerlink" title="&#x5341;&#x4E00;&#x3001;&#x4ECB;&#x7ECD;&#x4E86;&#x89E3;&#x7684;&#x8BBE;&#x8BA1;&#x6A21;&#x5F0F;"></a>&#x5341;&#x4E00;&#x3001;&#x4ECB;&#x7ECD;&#x4E86;&#x89E3;&#x7684;&#x8BBE;&#x8BA1;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二、volatile为什么能支持同步，却不支持原子性？"><span class="nav-number">2.12.</span> <span class="nav-text"><a href="#&#x5341;&#x4E8C;&#x3001;volatile&#x4E3A;&#x4EC0;&#x4E48;&#x80FD;&#x652F;&#x6301;&#x540C;&#x6B65;&#xFF0C;&#x5374;&#x4E0D;&#x652F;&#x6301;&#x539F;&#x5B50;&#x6027;&#xFF1F;" class="headerlink" title="&#x5341;&#x4E8C;&#x3001;volatile&#x4E3A;&#x4EC0;&#x4E48;&#x80FD;&#x652F;&#x6301;&#x540C;&#x6B65;&#xFF0C;&#x5374;&#x4E0D;&#x652F;&#x6301;&#x539F;&#x5B50;&#x6027;&#xFF1F;"></a>&#x5341;&#x4E8C;&#x3001;volatile&#x4E3A;&#x4EC0;&#x4E48;&#x80FD;&#x652F;&#x6301;&#x540C;&#x6B65;&#xFF0C;&#x5374;&#x4E0D;&#x652F;&#x6301;&#x539F;&#x5B50;&#x6027;&#xFF1F;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基础中的基础"><span class="nav-number">2.13.</span> <span class="nav-text"><a href="#Java&#x57FA;&#x7840;&#x4E2D;&#x7684;&#x57FA;&#x7840;" class="headerlink" title="Java&#x57FA;&#x7840;&#x4E2D;&#x7684;&#x57FA;&#x7840;"></a>Java&#x57FA;&#x7840;&#x4E2D;&#x7684;&#x57FA;&#x7840;</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">D_xiao</span>
</div>
<!--

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

-->

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
