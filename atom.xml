<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>疯狂DD</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://a1197319946.github.io/"/>
  <updated>2018-01-01T13:42:12.000Z</updated>
  <id>https://a1197319946.github.io/</id>
  
  <author>
    <name>D_xiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018第一记</title>
    <link href="https://a1197319946.github.io/2018/01/01/2018%E7%AC%AC%E4%B8%80%E8%AE%B0/"/>
    <id>https://a1197319946.github.io/2018/01/01/2018第一记/</id>
    <published>2018-01-01T13:15:15.000Z</published>
    <updated>2018-01-01T13:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写点东西了，<br>今天写点。</p><p>今天是2018年元旦，<br>刚刚搬到“新家”，<br>感觉一切好像也真的重新开始了。</p><p>2017这一年过的是在太快，快的一句话基本可以概括了，<br>搬了两次家，换了一次工作，北漂依然是北漂。</p><p>这一年过的不知道有什么意义，甚至没法做个总结，<br>不像前年，大前年，大大前年。</p><p>起码在大学的时候，起码大二往后的日子，我的“事迹”可以拿出来跟别人说，<br>吹吹牛逼。</p><p>然而北京这一年，别人觉得可能更牛逼了，我却一句都说不出口。<br>可能只想说一个字：惨。然而说给哪些不懂的人，又何必呢，<br>索性吞进肚子里了。</p><p>我有个不好的预感，2017这庸碌的一年可能是我奔三的日子的一个开始，<br>往后几年甚至几十年可能都是这样了。</p><p>不敢立flag，却不小心又立了一个。</p><p>算了。说说这一年吧。</p><p>在联想兢兢业业坚持了一年，后面实在受不了了索性辞职准备回家，</p><p>然而意外的是我没有回家，而是又在北京找了份code工作，有时我都不知道我是怎么想的，<br>我不知道做这一切值不值，只觉得可能不这样做就不值了。</p><p>可能从一开始就注定了你的路，一切自有安排，人是左右不了？</p><p>我不知道还要干code多久，不知道除了这份工作还能干什么才能对得起家里，<br>对得起各位亲朋好友的羡慕，对得起我自己不甘的心。</p><p>不管现在到凤凰金融是不是个错误的决定，不管接下来这一年会不会很累，会不会放弃，<br>这些看来都不重要了。因为工作终究不算我的难题。</p><p>反倒除了工作，我身上全是难以解决的难题。<br>该好好考虑了。</p><p>2018，今天新的一年，一切应该有个新的开始，<br>这一年，工作什么的都不重要了，该考虑下能影响自己一生的大事了。</p><p>越来越多的同学已经结婚，我说不着急，那是假的。<br>且不说家里着急了，<br>谁不想身边有个人一起，哪怕是说说话也好，<br>虽然在外面孤独惯了，却还是想有一个人能和自己一起生活，面对所有。<br>所以我一直想问：你在哪呢？是不是走丢了？</p><p>希望2018年我能找到你吧。</p><p>明天开始新一年的上班，一句话：稳住，我们能赢。</p><p>世上最怕坚持二字，挺到最后我一定会是赢家！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没写点东西了，&lt;br&gt;今天写点。&lt;/p&gt;
&lt;p&gt;今天是2018年元旦，&lt;br&gt;刚刚搬到“新家”，&lt;br&gt;感觉一切好像也真的重新开始了。&lt;/p&gt;
&lt;p&gt;2017这一年过的是在太快，快的一句话基本可以概括了，&lt;br&gt;搬了两次家，换了一次工作，北漂依然是北漂。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="生活小记" scheme="https://a1197319946.github.io/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="生活" scheme="https://a1197319946.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之路（二）数据库部分</title>
    <link href="https://a1197319946.github.io/2018/01/01/test1/"/>
    <id>https://a1197319946.github.io/2018/01/01/test1/</id>
    <published>2018-01-01T12:38:13.000Z</published>
    <updated>2018-01-01T12:38:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于本人只用过mysql数据库，所以本文整理的面试题也是基于mysql数据库的。</p><blockquote><p>画外音：以前一直觉得为什么面试非要问你原理性的东西呢，开发的工作是利用我们学的去创造一些东西，能达到目的不就行了，为什么买个车还要知道车轱辘是怎么造的？ 最近面试的几天，我慢慢明白了，一方面你对一个工具了解的多，更容易避免一些问题或想到一些更好的方法，另外一个很重要的方面，面试官可能想间接的了解你平日的工作情况，除了项目的描述，通过你学习的态度也可以大致了解了。</p></blockquote><h1 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h1><h2 id="一、mysql调优"><a href="#一、mysql调优" class="headerlink" title="一、mysql调优"></a>一、mysql调优</h2><p>1 尽量减少函数的使用，如Now(),Rand()等，对于函数，mysql不会查询缓存<br>2 为经常搜索、排序的字段建立索引，使用explain优化查询，使索引有效，通常索引失效的几种原因：</p><pre><code>1. 使用or条件，如果非用or,则两边都需加索引2. !=判断,不会走索引3. 使用函数或运算不会走索引4. like &apos;% aa&apos; 匹配前部 不走索引</code></pre><p> 3 关联查询join两表的字段需建立索引，MySQL内部会启动为你优化Join的SQL语句的机制，而且类型需要相同<br>4 避免select * ,减少查询字段可提高效率<br>5 查询一条数据使用limit 1 ,则查到1条记录时不会继续搜索<br>6 定长的字段使用char类型而不是varchar</p><h2 id="二、联合索引什么时候会失效"><a href="#二、联合索引什么时候会失效" class="headerlink" title="二、联合索引什么时候会失效"></a>二、联合索引什么时候会失效</h2><pre><code>1. 条件包含索引第一列或包含索引前n列或全部，会用到索引，此时索引的条件列中间不能有其他条件，也就是说索引条件要放到一起，顺序无所谓。2. 如果不包含第一列，或类似第一列和最后一列，或索引列条件中间有其他条件，则查询用不到索引。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table test(id int ,c1 varchar(20) , c2 varchar(20) , c3 varchar(30)) ;</span><br><span class="line">create index test_ix on test(c1,c2,c3) ;</span><br><span class="line"> </span><br><span class="line">-- 会用到索引的查询</span><br><span class="line">select * from test where c1 = &apos;1&apos; </span><br><span class="line">select * from test where c1 = &apos;1&apos; and c2 = &apos;2&apos;</span><br><span class="line">select * from test where c2 = &apos;1&apos; and c1 = &apos;3&apos;</span><br><span class="line">select * from test where c1 = &apos;3&apos; and c3=&apos;4&apos;</span><br><span class="line">select * from test where c1 = &apos;1&apos; and c2 = &apos;2&apos; and c3 = &apos;3&apos;</span><br><span class="line"> </span><br><span class="line">-- 不会用索引的查询</span><br><span class="line">select * from test where c2 = &apos;2&apos; </span><br><span class="line">select * from test where c2 = &apos;2&apos; and c3 = &apos;3&apos;</span><br><span class="line">select * from test where c1 = &apos;2&apos; and id=4 and c2 = &apos;3&apos;</span><br></pre></td></tr></table></figure><h2 id="三、索引是怎么实现的，b-tree-原理，为什么快等"><a href="#三、索引是怎么实现的，b-tree-原理，为什么快等" class="headerlink" title="三、索引是怎么实现的，b+ tree 原理，为什么快等"></a>三、索引是怎么实现的，b+ tree 原理，为什么快等</h2><p>引用一篇文章<a href="https://www.cnblogs.com/tgycoder/p/5410057.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><h2 id="四、myisam和innodb区别，myisam为什么快"><a href="#四、myisam和innodb区别，myisam为什么快" class="headerlink" title="四、myisam和innodb区别，myisam为什么快"></a>四、myisam和innodb区别，myisam为什么快</h2><pre><code>1 myisam不支持事务、外键，innodb支持2 myisam支持fulltext全文索引，innodb不支持3 myisam会保存行数，select(*)快，innodb需要扫描整表才知道4 mysiam读的性能高，写的性能低，因为mysiam写的时候锁表，而innodb是锁行</code></pre><blockquote><p>mysiam读的快的原因：首先mysiam索引与数据块分开放，因此读取更快；另外，innodb要维护比mysiam更多的引擎，比如维护事务，就要维护MVVC(多版本控制)，每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同，而这又是一个随着事务的创建而不断增长的数字，所以innodb查询会慢一些。</p></blockquote><h2 id="五、数据库隔离级别"><a href="#五、数据库隔离级别" class="headerlink" title="五、数据库隔离级别"></a>五、数据库隔离级别</h2><p>1 未提交读：(Read Uncommitted)</p><pre><code>会引起脏读的情况。比如事务a修改了一条数据而未提交，事务b读取了这条数据发现有更新，而事务a又将数据修改回原来的样子提交，这样事务b读的数据即为脏数据，也叫脏读。如何解决这个问题？数据的隔离性是靠锁机制来实现，无非是锁的位置不同而已，之前是只要操作完该数据就立马释放掉锁，现在是把释放锁的位置调整到事务提交之后释放锁，此时在事务提交前，其他进程是无法对该行数据进行读取的，包括任何操作。这也就是事务的第二个隔离性，读已提交（Read Committed），或者也可以叫不可重复读。</code></pre><p>2 已提交读（Read Committed） 大多数数据库默认的隔离级别</p><pre><code>也可以叫不可重复读。这种情况中在同一个事务中如果两次读取相同的数据时，最后的结果可能是不一致。比如事务a两次查询一条记录，事务b在这之间更新了这条记录并已提交，则事务a两次查询的结果将不一致。这个问题称为“不可重复读”。还有另外一种情况。如果事务a更新了所有行未提交，事务b插入一条记录并已提交，这时事务a查询发现还有一条记录没有更新成功，这就是所谓的“幻读”。那么如何解决“不可重复读”和“幻读”？mysql采取的是MVCC并发版本控制来解决这个问题。具体是：如果事务中存在多次读取同样的数据，MySQL第一次读的时候仍然会保持选择读最新提交事务的数据，之后再读时，mysql会取第一次读取的数据作为结果。这样就保证了同一个事务多次读取数据时数据的一致性。mysql把这种解决方案叫做：可重复度（Repeatable-Read)，第三个隔离性，也是mysql默认的隔离级别。</code></pre><p>3 可重复读（Repeatable-Read) mysql数据库所默认的级别</p><pre><code>可重复读是mysql默认的隔离级别，解决了脏读和幻读，但也是有问题的，举个例子：两个事物同时开启同时读到一条记录数值6000，需要进行减3000的操作，由于事务a b的操作都还没提交，都是不可见的，所以同时将6000更新为3000，也就是说还有3000更新丢失了。这个问题即“更新丢失”。这个时候序列化读的作用就出现了。</code></pre><p>4 序列化读（serializable）</p><pre><code>序列化读会自动在锁住你要操作的整个表的数据，如果另一个进程事务想要操作表里的任何数据就需要等待获得锁的进程操作完成释放锁。可避免脏读、不可重复读、幻读的发生。当然性能会下降很多，会导致很多的进程相互排队竞争锁。这种隔离级别是很少用的，会极大影响数据库的性能，当然我们要解决上面的问题，可以在应用层进行加锁控制。</code></pre><h2 id="六、数据库禁用不可重复读如何实现"><a href="#六、数据库禁用不可重复读如何实现" class="headerlink" title="六、数据库禁用不可重复读如何实现"></a>六、数据库禁用不可重复读如何实现</h2><pre><code>MVVC ,多版本控制 （ 具体可以看问题五中的描述）</code></pre><h2 id="七、事务原子性如何实现的，其原理？"><a href="#七、事务原子性如何实现的，其原理？" class="headerlink" title="七、事务原子性如何实现的，其原理？"></a>七、事务原子性如何实现的，其原理？</h2><p>在同一个事务内部的一组操作必须全部执行成功（或者全部失败），这就是事务处理的原子性。原子性的实现是基于日志的REDO/UNDO机制。</p><blockquote><p>为了实现原子性，需要通过日志：将所有对<br>数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已<br>经执行成功的操作撤销，从而达到“全部操作失败”的目的。最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash<br>recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行<br>UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash<br>recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p></blockquote><h2 id="八、锁表问题"><a href="#八、锁表问题" class="headerlink" title="八、锁表问题"></a>八、锁表问题</h2><p>锁表有很多种情况，先简单介绍下mysql的三种锁：</p><pre><code>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</code></pre><p>需要注意的是：</p><blockquote><p>行级锁并不是直接锁记录，而是锁索引，如果一条SQL语句用到了主键索引，mysql会锁住主键索引；如果一条语句操作了非主键索引，mysql会先锁住非主键索引，再锁定主键索引。而死锁产生的根本原因是两个以上的进程相互等待资源，形成环路。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p></blockquote><p>所以我们要分析锁表，也就是对索引的组合使用情况进行分析，本人对此了解还比较少，只是简单的知道几种情况，大家可以参考下这篇文章<a href="http://www.cnblogs.com/metoy/p/5545580.html" target="_blank" rel="noopener">Mysql加锁过程详解</a></p><p>好，根据上面说的主键索引和非主键索引，这里举个例子：</p><p>一张表中有三个字段如下：</p><p>　　　　<code>id</code>  主键索引<br>　　　　<code>name</code> index 索引<br>　　　　<code>age</code>  普通字段</p><p>　　　　例如下面两条语句 第一条语句会优先使用<code>name</code>索引，因为name不是主键索引，还会用到主键索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① update mk_user set name =&apos;1&apos; where `name`=&apos;idis12&apos;;</span><br><span class="line">② update mk_user set name=&apos;12&apos;  where id=12;</span><br></pre></td></tr></table></figure><p>　　　　第二条语句是首先使用主键索引,再使用name索引 如果两条语句同时执行，第一条语句执行了name索引等待第二条释放主键索引，第二条执行了主键索引等待第一条的name索引，这样就造成了死锁。（//todo 此处描述有问题，标记下）<br>　　　　<br>　　　　解决方法：改造第一条语句 使其根据主键值进行更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//改造后</span><br><span class="line">update mk_user set name=&apos;1&apos; where id=(select id from mk_user where name=&apos;idis12&apos; );</span><br></pre></td></tr></table></figure></p><p>再举个例子，这是个常见的AB-BA问题</p><p>表t中有两个字段，id,name,有两个事务同时进行更新/删除操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--事务1</span><br><span class="line">begin;</span><br><span class="line">UPDATE `user1` set name=... where id=1;</span><br><span class="line">DELETE from user where name=&apos;小红&apos;;</span><br><span class="line">COMMIT;</span><br><span class="line">--事务2</span><br><span class="line">begin;</span><br><span class="line">UPDATE `user1` set name=... where id=2;</span><br><span class="line">DELETE from user where name=&apos;小明&apos;;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>问题：在什么情况下会发生死锁？</p><p>这个情况发生死锁为记录行冲突，两个事务操作相同的数据，事务1为job 1，2；事务2为job 2,1<br>也就是说数据如果像如下这样，就可能死锁。事务1在修改记录1 时获取1的锁，事务2修改记录2时获取2的锁，这时事务1删除记录2需要获取2 的锁，而事务2删除记录1又需要获取1的锁，出现了循环等待。</p><pre><code>id   name1    小明2    小红</code></pre><p>具体锁分析可以参考这篇文章，写的不错<a href="https://www.cnblogs.com/LBSer/p/5183300.html" target="_blank" rel="noopener">Mysql死锁问题分析</a></p><h2 id="九、分库分表分区"><a href="#九、分库分表分区" class="headerlink" title="九、分库分表分区"></a>九、分库分表分区</h2><p>引用一篇文章<a href="https://www.cnblogs.com/langtianya/p/4997768.html" target="_blank" rel="noopener">分库分表</a></p><h2 id="十、Mysql主从同步原理"><a href="#十、Mysql主从同步原理" class="headerlink" title="十、Mysql主从同步原理"></a>十、Mysql主从同步原理</h2><p>在master机器上，主从同步事件会被写到特殊的log文件中(binary-log);在slave机器上，slave读取主从同步事件，并根据读取的事件变化，在slave库上做相应的更改。<br>主从同步事件有3种形式:statement、row、mixed。</p><pre><code>1. statement：会将对数据库操作的sql语句写入到binlog中。2. row：会将每一条数据的变化写入到binlog中。3. mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。</code></pre><p>具体操作：<br>1 当master上的数据发生改变的时候，该事件(insert、update、delete)变化会按照顺序写入到binlog中。<br>2 当slave连接到master的时候，master机器会为slave开启binlog dump线程。当master 的 binlog发生变化的时候，binlog dump线程会通知slave，并将相应的binlog内容发送给slave。<br>3 当主从同步开启的时候，slave上会创建2个线程。</p><pre><code>1 I/O线程。该线程连接到master机器，master机器上的binlog dump线程会将binlog的内容发送给该I/O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log。2 SQL线程。该线程读取I/O线程写入的relay log。并且根据relay log的内容对slave数据库做相应的操作。</code></pre><p>关于查看线程：<br>使用SHOW PROCESSLIST命令可以查看。</p><h2 id="十一、高并发下应采用悲观锁还是乐观锁？"><a href="#十一、高并发下应采用悲观锁还是乐观锁？" class="headerlink" title="十一、高并发下应采用悲观锁还是乐观锁？"></a>十一、高并发下应采用悲观锁还是乐观锁？</h2><p>首先简单介绍下这两种锁：<br>1 乐观锁</p><pre><code>就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。乐观锁只在操作（insert/update/delete）时进行锁操作，的实现一般是加版本号，比如做更新操作时，类似如下这样操作：update table set name=... ,version=version+1 where id=... and version=001 ， 每次更新version版本号+1，并校验这条数据是否已经被操作了。</code></pre><p>2 悲观锁</p><pre><code>还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。悲观锁会阻塞读。悲观锁为读锁，在select时就行锁操作，使用如下：select .... for update</code></pre><p>好，那什么场景下使用这两种锁合适呢？</p><pre><code>1 高并发情况下，如题所说，这时候锁的竞争会非常激烈，这时如果使用乐观锁会经常发生操作失败的情况，这时我们还需维护一套重试机制，将会十分影响性能，而用悲观锁，在读取时就获取锁，读到就会成功，不会有因争用而失败的情况，所以悲观锁更合适。2 而并发不那么高的情况，各种业务又比较多，我们未提高查询效率，我们可以使用乐观锁。</code></pre><hr><p>对于里面索引b+ tree和分库分表本人研究不深，暂先引用下别人的好文，给大家已参考，等后面我熟悉之后再写文分析 ~  </p><p>可算写完了 ~  呼 ~ 溜了 ~~~</p><p>待续…….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于本人只用过mysql数据库，所以本文整理的面试题也是基于mysql数据库的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;画外音：以前一直觉得为什么面试非要问你原理性的东西呢，开发的工作是利用我们学的去创造一些东西，能达到目的不就行了，为什么买个车还要知道车轱辘是怎么造的？
      
    
    </summary>
    
      <category term="面试题" scheme="https://a1197319946.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="java" scheme="https://a1197319946.github.io/tags/java/"/>
    
      <category term="mysql" scheme="https://a1197319946.github.io/tags/mysql/"/>
    
      <category term="面试" scheme="https://a1197319946.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之路（一）Java基础部分</title>
    <link href="https://a1197319946.github.io/2018/01/01/Java%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    <id>https://a1197319946.github.io/2018/01/01/Java面试之路（一）Java基础部分/</id>
    <published>2018-01-01T12:37:33.000Z</published>
    <updated>2018-01-01T12:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近辞职，开始了一轮又一轮腥风血雨的面试，开个专栏，记录下面试中的各种疑难杂症问题，面试的公司有58企服、便利蜂，美团等，给大家分享下。专栏将分为几部分：java基础、数据库部分、分布式架构中间件部分、网络及算法部分。本篇来说下基础部分。博主刚毕业一年，加上大四一年外包经验，工作两年，本以为面试应该比较轻松，面了发现还是挺难的……</p><blockquote><p>可谓雄关漫道真如铁，而今迈步从头越，从头越，苍山如海，残阳如血。</p></blockquote><hr><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="一、关于线程池"><a href="#一、关于线程池" class="headerlink" title="一、关于线程池"></a>一、关于线程池</h2><p> <strong>1. java自带的线程池</strong></p><p>  a. newCachedThreadPool(创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。)<br>  b.  newFixedThreadPool(创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。)<br>  c. newScheduledThreadPool(创建一个定长线程池，支持定时及周期性任务执行。)<br>  d.newSingleThreadExecutor(创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。)</p><p> <strong>2. 自己如何实现线程池</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">    .setNameFormat(&quot;demo-pool-%d&quot;).build();</span><br><span class="line"></span><br><span class="line">//Common Thread Pool</span><br><span class="line">ExecutorService pool = new ThreadPoolExecutor(5, 200,</span><br><span class="line">     0L, TimeUnit.MILLISECONDS,</span><br><span class="line">     new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">pool.shutdown();//gracefully shutdown</span><br></pre></td></tr></table></figure><ul><li>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</li><li>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li><li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p><pre><code>TimeUnit.DAYS;               //天 TimeUnit.HOURS;             //小时TimeUnit.MINUTES;           //分钟 TimeUnit.SECONDS;           //秒TimeUnit.MILLISECONDS;      //毫秒 TimeUnit.MICROSECONDS;      //微妙TimeUnit.NANOSECONDS;       //纳秒</code></pre></li><li><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p></li></ul><pre><code>ArrayBlockingQueue; LinkedBlockingQueue; SynchronousQueue;</code></pre><p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p><ul><li>threadFactory：线程工厂，主要用来创建线程；</li><li><p>handler：表示当拒绝处理任务时的策略，有以下四种取值：</p><pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</code></pre></li></ul><h2 id="二、关于Lock和Synchronized"><a href="#二、关于Lock和Synchronized" class="headerlink" title="二、关于Lock和Synchronized"></a>二、关于Lock和Synchronized</h2><p> <strong>1. 两种锁有什么区别</strong></p><p> 1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，但是增加了锁投票，定时锁等候和中断锁等候，。比如ReentrantLock获取锁定与三种方式：</p><pre><code>a) lock(),如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁b) tryLock(),如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false； c)tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断</code></pre><p><strong>2 、ReentrantLock增加了等待条件，可以看ArrayBlockingQuene的实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">        if (capacity &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        this.items = new Object[capacity];</span><br><span class="line">        lock = new ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition();//设置不空条件</span><br><span class="line">        notFull =  lock.newCondition();//设置不满条件</span><br><span class="line">    &#125;</span><br><span class="line">    public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();//等待队列不满条件</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中</p><p> 4、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</p><p> <strong>2. Synchronized修饰普通方法和静态方法有什么区别</strong></p><pre><code>修饰普通方法为对象锁，修饰静态方法为类锁</code></pre><h2 id="三、HashMap底层原理"><a href="#三、HashMap底层原理" class="headerlink" title="三、HashMap底层原理"></a>三、HashMap底层原理</h2><p> <strong>1. 底层结构</strong></p><pre><code>数组+链表；jdk8优化后链表长度超过8会转化为红黑树</code></pre><p> <strong>2. 散列算法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//jdk8已经进行简化，改为1次16位右移异或混合，而不是4次</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">        int h = hashSeed;</span><br><span class="line">        if (0 != h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//hashcode用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。获取下标</span><br><span class="line"> static int indexFor(int h, int length) &#123;</span><br><span class="line">        return h &amp; (length-1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3. 扩容原理</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">//两倍扩容</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        hash = (null != key) ? hash(key) : 0;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>4. jdk8对HashMap的优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 链表长度大于8时，改为红黑树结构</span><br><span class="line">// 实现如下：</span><br><span class="line"> private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">    if (tab != null) &#123;</span><br><span class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; 1);</span><br><span class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</span><br><span class="line">            synchronized (b) &#123;</span><br><span class="line">                if (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              null, null);</span><br><span class="line">                        if ((p.prev = tl) == null)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        else</span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//红黑树的具体实现需要了解下</span><br></pre></td></tr></table></figure><p> <strong>5.  HashMap put方法原理</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">//允许key为null</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">//key不是null时计算哈希值得到数组下标</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">//遍历该位置链表，如果已有此value则直接进行替换，并返回原来的值</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//如果不存在此value,则插入节点</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>6. HashMap如何调整性能</strong></p><pre><code>适当修改分组组数及加载因子（默认16*0.75），保证分组组数* 加载因子&gt;元素总量，避免由于出发扩容重新散列印象效率。另，分组组数越大，数据将被散列到更多的小组，查询效率高；加载因子越小，扩容发生的越早，也就是在尽可能的保证效率。</code></pre><p> <strong>7. HashMap是否线程安全</strong></p><pre><code>HashMap不支持多个线程并发操作，会出现并发错误，在并发的场景下可以用HashTable，可以使用Collections工具类中的synchronizedMap方法或者有更好的并发性能的ConcurrentHashMap</code></pre><h2 id="四、TreeMap如何保证有序"><a href="#四、TreeMap如何保证有序" class="headerlink" title="四、TreeMap如何保证有序"></a>四、TreeMap如何保证有序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//在初始化时，构造器会传入一个比较器参数</span><br><span class="line"> public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">        this.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">//put时根据比较原则进行插入元素</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            compare(key, key); // type (and possibly null) check</span><br><span class="line"></span><br><span class="line">            root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">            size = 1;</span><br><span class="line">            modCount++;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        // split comparator and comparable paths</span><br><span class="line">        Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">        if (cpr != null) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                else</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t != null);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (key == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">            do &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                else</span><br><span class="line">                    return t.setValue(value);</span><br><span class="line">            &#125; while (t != null);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        else</span><br><span class="line">            parent.right = e;</span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="五、NIO与IO的区别及何种场景使用"><a href="#五、NIO与IO的区别及何种场景使用" class="headerlink" title="五、NIO与IO的区别及何种场景使用"></a>五、NIO与IO的区别及何种场景使用</h2><p><strong>1 使用场景</strong></p><pre><code>**NIO**优势在于一个线程管理多个通道；但是数据的处理将会变得复杂；如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，采用这种； **传统的IO** 适用于一个线程管理一个通道的情况；因为其中的流数据的读取是阻塞的；如果需要管理同时打开不太多的连接，这些连接会发送大量的数据；</code></pre><p><strong>2 NIO vs IO区别</strong></p><p>1 IO是面向流的，NIO是面向缓冲区的</p><pre><code>a Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方；b NIO则能前后移动流中的数据，因为是面向缓冲区的</code></pre><p>2 IO流是阻塞的，NIO流是不阻塞的</p><pre><code>a Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了b Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。 c 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</code></pre><p>3 选择器</p><pre><code>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 </code></pre><h2 id="六、CAS和CAP"><a href="#六、CAS和CAP" class="headerlink" title="六、CAS和CAP"></a>六、CAS和CAP</h2><p> <strong>1. CAS</strong></p><p> CAS:Compare and Swap, 翻译成比较并交换。<br>java.util.concurrent包中借助CAS实现了区别于synchronouse同步锁的一种乐观锁。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//可以看下AtomicInteger的源码 i++操作</span><br><span class="line">private volatile int value;</span><br><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;   </span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">//compareAndSwapInt方法即拿预期值expect和this当前内存值比较，相同则返回true,并赋新值update.</span><br></pre></td></tr></table></figure><p> <strong>2. CAP</strong></p><blockquote><p> 引用一下  ~<br><a href="http://www.blogjava.net/hello-yun/archive/2012/04/27/376744.html" target="_blank" rel="noopener">CAP原理</a></p></blockquote><h2 id="七、JVM内存模型，jdk8有何种改进"><a href="#七、JVM内存模型，jdk8有何种改进" class="headerlink" title="七、JVM内存模型，jdk8有何种改进"></a>七、JVM内存模型，jdk8有何种改进</h2><p>  jvm内存由堆、栈、本地方法栈、方法区等组成</p><ol><li>堆。存放通过new创建的对象，分新生代、老年代</li><li>栈。每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。  -xss:设置每个线程的堆栈大小. JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。</li><li>本地方法栈。用于支持native方法的执行，存储了每个native方法调用的状态</li><li>方法区 。即持久代Permanet Space.</li></ol><p>下图为堆内存模型（图有点问题，持久带为方法区，不应该画在堆内存中）。<br><img src="http://img.blog.csdn.net/20171117144601868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnJpZ2h0aW5nZm9yYW1iaXRpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>普及一下gc算法：</p><pre><code>年轻代：复制算法。 此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。老年代：并行（标记清除）。关于标记清除算法：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。并行回收（标记整理）.关于标记整理算法： 此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</code></pre><p>顺便提一下对象何时进行销毁：</p><pre><code>这也是面试官喜欢问的一个问题，一般我们会回答对象在gc的时候进行销毁，那面试官又会问，gc的时候jvm怎么知道该销毁哪些对象呢？这个问题有点恶心，多次碰到简单说下：一个对象创建后被放置在JVM的堆内存中，当永远不再引用这个对象时，它将被JVM在堆内存中回收。即当对象在JVM运行空间中无法通过根集合到达(找到)时,这个对象被称为垃圾对象。根集合是由类中的静态引用域与本地引用域组成的。JVM通过根集合索引对象。 这时面试官又会问，那什么情况下对象不会被回收呢（问的是内存泄露什么时候会发生），请把滚动条拉到最下面基础中基础，第一题有总结。</code></pre><p>主要来说下jdk8的改进：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以元空间取代永久代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间</span><br><span class="line">并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</span><br><span class="line"></span><br><span class="line">　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</span><br><span class="line"></span><br><span class="line">　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</span><br><span class="line">　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</span><br><span class="line">　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。</span><br><span class="line"></span><br><span class="line">jvm参数不再需要指定 PermSize 和 MaxPermSize。而是指定 MetaSpaceSize 和 MaxMetaSpaceSize的大小。</span><br></pre></td></tr></table></figure></p><h2 id="八、JVM调优"><a href="#八、JVM调优" class="headerlink" title="八、JVM调优"></a>八、JVM调优</h2><p> <strong>1. jvm参数修改包括堆内存设置及垃圾回收器设置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，过多的GC和Full GC是会占用很多的系统资源（主要是CPU），</span><br><span class="line">影响系统的吞吐量。特别要关注Full GC，因为它会对整个堆进行整理。</span><br><span class="line">出现Full GC的几种原因：</span><br><span class="line"></span><br><span class="line"> 1. 老年代空间不足</span><br><span class="line"> 2. 新生代设置过小或过大</span><br><span class="line">   过小会导致大对象直接进入老年代，诱发full gc;</span><br><span class="line">   过大会导致老年代过小（堆总量一定），诱发full gc，另外会导致新生代gc耗时严重,</span><br><span class="line">   新生代最好占堆内存 1/3 或 3/8</span><br><span class="line"> 3. Survivor或Eden区设置过小或过大</span><br><span class="line">   过小导致对象从Eden区直接进去到老年代</span><br><span class="line">   过大导致Eden过小，增加了GC频率</span><br><span class="line">   可以使用-XX:SurvivorRatio=n 手动设置，默认n为8，即Survivor1：Survivor0：Eden=1:1:8</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">另外，可选择适合该应用的垃圾回收器：</span><br><span class="line"></span><br><span class="line"> XX:+UseSerialGC:设置串行收集器</span><br><span class="line">-XX:+UseParallelGC:设置并行收集器</span><br><span class="line">-XX:+UseParalledlOldGC:设置并行年老代收集器</span><br><span class="line">-XX:+UseConcMarkSweepGC:设置并发收集器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">垃圾回收统计信息：</span><br><span class="line">-XX:+PrintGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br></pre></td></tr></table></figure><p> <strong>2. 代码调优，防止大对象，大数组频繁创建</strong></p><h2 id="九、CPU和内存飙升的一般情况和解决思路"><a href="#九、CPU和内存飙升的一般情况和解决思路" class="headerlink" title="九、CPU和内存飙升的一般情况和解决思路"></a>九、CPU和内存飙升的一般情况和解决思路</h2><p> <strong>1. 内存飙升可能与线程阻塞、死循环有关，解决方法如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 使用jps查找出java进程的pid，如3707</span><br><span class="line">2 使用top -p 3707观察进程情况，然后Shift+h,显示该进程的所有线程。</span><br><span class="line">3 找出CPU消耗较多的线程id，如3720，将3720转换为16进制0x7d0，注意是小写哦</span><br><span class="line">4 使用jstack 3707 | grep -A 10 0x7d0 来查询出具体的线程状态。</span><br></pre></td></tr></table></figure><p> <strong>2. 内存占用高一般是创建对象太多，或有大数组之类，排查方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 通过jstat -gc -h10 pid 1000 查看gc情况</span><br><span class="line"> 通过jmap -heap pid 查看堆内存情况</span><br><span class="line"> 通过jmap -histo pid 查看堆中对象创建情况    </span><br><span class="line"> 关于内存溢出除了对象创建频繁另外的一种可能性：由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久</span><br><span class="line">代的内存溢出。最典型的场景就是，在JSP页面比较多的情况，容易出现永久代内存溢出。</span><br></pre></td></tr></table></figure><h2 id="十、Quene的原理"><a href="#十、Quene的原理" class="headerlink" title="十、Quene的原理"></a>十、Quene的原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">主要说一下java阻塞队列BlockingQuene。</span><br><span class="line">它的入队出队主要有几种方法：</span><br><span class="line"></span><br><span class="line"> 1. add remove 队列满的时候会抛异常</span><br><span class="line"> 2. offer poll 队列满了会返回false</span><br><span class="line"> 3. put take 队列满了会阻塞（等待）</span><br><span class="line">当然我们用阻塞的话只能用最后一种方式，</span><br><span class="line">常用的实现有两种ArrayBlockingQueue、LinkedBlockingQueue</span><br><span class="line">ArrayBlockingQueue实现如下：</span><br><span class="line"></span><br><span class="line">  public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            return extract();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    可以看到使用一个ReentrantLock实现的，而LinkedBlockingQueue的实现略有不同，用了两个ReentrantLock。来看下：</span><br><span class="line">     public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        if (e == null) throw new NullPointerException();</span><br><span class="line">        // Note: convention in all put/take/etc is to preset local var</span><br><span class="line">        // holding count negative to indicate failure unless set.</span><br><span class="line">        int c = -1;</span><br><span class="line">        Node&lt;E&gt; node = new Node(e);</span><br><span class="line">        final ReentrantLock putLock = this.putLock;</span><br><span class="line">        final AtomicInteger count = this.count;</span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Note that count is used in wait guard even though it is</span><br><span class="line">             * not protected by lock. This works because count can</span><br><span class="line">             * only decrease at this point (all other puts are shut</span><br><span class="line">             * out by lock), and we (or some other waiting put) are</span><br><span class="line">             * signalled if it ever changes from capacity. Similarly</span><br><span class="line">             * for all other uses of count in other wait guards.</span><br><span class="line">             */</span><br><span class="line">            while (count.get() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            if (c + 1 &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        if (c == 0)</span><br><span class="line">            signalNotEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    public E take() throws InterruptedException &#123;</span><br><span class="line">        E x;</span><br><span class="line">        int c = -1;</span><br><span class="line">        final AtomicInteger count = this.count;</span><br><span class="line">        final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count.get() == 0) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            if (c &gt; 1)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        if (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">//入队和出队是不同的锁</span><br></pre></td></tr></table></figure><h2 id="十一、介绍了解的设计模式"><a href="#十一、介绍了解的设计模式" class="headerlink" title="十一、介绍了解的设计模式"></a>十一、介绍了解的设计模式</h2><p> <strong>1. 单例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//醉汉</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private Singleton()&#123;&#125;;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    public static Singleton getInstance ()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">//懒汉</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">            if(instance == null &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">           return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//对懒汉模式加锁的优化（volatile+双重锁）</span><br><span class="line"> public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">            if(instance == null &#123;</span><br><span class="line">                synchronized（Singleton.class）&#123;</span><br><span class="line">           if(instance == null)&#123;</span><br><span class="line">                        instance = new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>2. 工厂</strong><br> <strong>3. 代理</strong><br> <strong>4. 包装</strong><br> ………..</p><h2 id="十二、volatile为什么能支持同步，却不支持原子性？"><a href="#十二、volatile为什么能支持同步，却不支持原子性？" class="headerlink" title="十二、volatile为什么能支持同步，却不支持原子性？"></a>十二、volatile为什么能支持同步，却不支持原子性？</h2><p>这两句话看起来好像是矛盾的，我们来一一分析下。</p><p>　　首先，我们知道volatile是一个线程安全的修饰符，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。<br>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。<br>　　当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p><p>　　<br>当一个变量定义为 volatile 之后，将具备两种特性：</p><p>　　1.保证此变量对所有的线程的可见性，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次get时立即从主内存刷新。<br>　　2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），所以就禁止了cpu的重排序操作。<br>　　<br>volatile 性能：</p><p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p><p><strong>当变量用volatile修饰是，从上面可以知道set/get 都是线程安全的，但这是否说明volatile是原子的？</strong><br>答案是否定的，比如i++ , 这个操作实际是 i = i + 1, 它不是一个原子的行为，在操作的过程中，是不安全的，如要实现安全，可采用CAS方案进行同步，像AtomicInteger、AtomicLong等就是基于volatile的可见性 + CAS控制 i++操作的原子性的。　　</p><hr><p>以上为我接触的感觉基础中比较深入的问题，下面的问题我感觉比较简单但是必须熟练掌握，答案不一一列举。有问题的自行百度，如若无果请留言。</p><hr><h2 id="Java基础中的基础"><a href="#Java基础中的基础" class="headerlink" title="Java基础中的基础"></a>Java基础中的基础</h2><p>一、内存溢出和内存泄露发生原因<br>1 内存溢出（比较简单暂不列举）<br>2 内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。<br>内存泄露的原因：</p><pre><code>1、静态集合类引起内存泄露： 像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 2 各种连接、流未关闭</code></pre><p>二、集合框架对比</p><ol><li>ArrayList与linkedList、Vector的区别</li><li>HashMap与HashTable的区别</li><li>TreepMap,SortedMap比较器的用法</li><li>ArrayList扩容机制<br> jdk1.7 前 a*1.5 + 1<br>jdk1.7 后 a + a&gt;&gt;1</li></ol><p>三、接口抽象类的区别</p><ol><li>接口中定义的变量默认即常量；抽象类中变量为普通属性，每个对象都有一份。</li><li>接口中的方法都是抽象方法不能写实现，抽象类中中可以有抽象方法也可以有非抽象方法，也就是说可以有实现</li><li>jdk8开始接口中的方法可以写具体实现，static修饰的静态方法和default修饰的默认方法</li></ol><p>四、线程的生命周期<br>新建、就绪、运行、阻塞、死亡</p><blockquote><p>先写这么多，后面待续………..</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近辞职，开始了一轮又一轮腥风血雨的面试，开个专栏，记录下面试中的各种疑难杂症问题，面试的公司有58企服、便利蜂，美团等，给大家分享下。专栏
      
    
    </summary>
    
      <category term="面试题" scheme="https://a1197319946.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="java" scheme="https://a1197319946.github.io/tags/java/"/>
    
  </entry>
  
</feed>
